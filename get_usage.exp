#!/usr/bin/expect -f

set timeout 15
log_user 1

# Track spawned PID for cleanup
set spawn_pid 0

# Cleanup procedure: kill spawned process and exit
proc cleanup {exit_code} {
    global spawn_pid spawn_id
    if {$spawn_pid != 0} {
        # Try graceful close first
        catch {close -i $spawn_id}
        # Then force kill if still running
        catch {exec kill -TERM $spawn_pid}
        after 500
        catch {exec kill -KILL $spawn_pid}
    }
    exit $exit_code
}

# Trap signals to ensure cleanup
trap {cleanup 1} {SIGINT SIGTERM SIGHUP}

# Spawn claude with /config
spawn claude /config
set spawn_pid [exp_pid]

# Wait for the config menu to appear
# Also detect if claude is asking questions (first-time setup, etc)
expect {
    "Config" { }
    -re {(?i)would you like|do you want|enter your|please choose|select|y/n|\?.*:} {
        puts "ERROR: Claude is prompting for input"
        cleanup 1
    }
    -re {(?i)error|failed|unable} {
        puts "ERROR: Claude reported an error"
        cleanup 1
    }
    timeout {
        puts "ERROR: Timeout waiting for config menu"
        cleanup 1
    }
    eof {
        puts "ERROR: Process exited unexpectedly"
        cleanup 1
    }
}

# Short delay for UI to settle
sleep 1

# Send Tab to move to Usage tab
send "\t"

# Wait for Usage tab to appear with data
expect {
    "Current session" { }
    timeout {
        puts "ERROR: Timeout waiting for usage tab"
        cleanup 1
    }
    eof {
        puts "ERROR: Process exited unexpectedly"
        cleanup 1
    }
}

# Short delay for data to load
sleep 1

# Send Escape to exit claude gracefully
send "\x1b"

# Wait for process to exit (with timeout)
expect {
    eof { }
    timeout {
        # Process didn't exit gracefully, force kill
        cleanup 0
    }
}

# Ensure process is fully terminated
catch {close}
catch {wait}

exit 0
